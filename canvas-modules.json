{"":"var rangeTicks = function (min, max, step)  {\n    var incr = function (y) {\n        return Math.floor((y+step)/step)*step;\n    },\n    x = incr(min),\n    t = [];\n    while (x < max) {\n        t.push(x);\n        x = incr(x);\n    }\n    return t;\n}\nreturn rangeTicks","CartesianRect":"var Vector = this.load('Vector');\n\nvar CartesianRect = function (rect, minx, maxx, miny, maxy) {\n    this._o = new Vector(minx, miny);\n    this._d = this._o.del(maxx, maxy);\n    this._map = Vector.mapper(minx, miny, maxx, maxy, 0, rect.h, rect.w, 0);\n    this._rect = rect;\n};\nCartesianRect.prototype.rect = Vector.vectorizeArgs(function (o, d) {\n    o = o || this._o;\n    d = o.add(d || this._d);\n    var mo = this._map(o.x, d.y);\n    return this._rect.rect(this._map(d.x, o.y).del(mo), mo);\n});\nCartesianRect.prototype.fill = function () {\n    return this._rect.fill();\n};\nCartesianRect.prototype.hline = function (y) {\n    return this._rect.hline(this._map(0,y).y);\n};\nCartesianRect.prototype.vline = function (x) {\n    return this._rect.vline(this._map(x, 0).x);\n};\n\nCartesianRect.prototype.mapDrawing = function (fn) {\n    var o = this._map(0,0),\n        tx = o.x,\n        ty = o.y,\n        sx = this._rect.w/this._d.x;\n        sy = -this._rect.h/this._d.y;\n\n    this._rect.mapDrawing(function (ctx) {\n        ctx.save();\n        ctx.translate(tx, ty);\n        ctx.scale(sx, sy);\n        fn.call(null, ctx);\n        ctx.restore();\n    });\n};\n\nreturn CartesianRect;","Graph":"var copyProps = this.load('copyProps');\n\nvar drawGraph = function (carta, opt) {\n    \n    var MAXX = opt.maxx,\n        MINX = opt.minx,\n        MAXY = opt.maxy,\n        MINY = opt.miny,\n        MAJORX = opt.majorx,\n        MAJORY = opt.majory,\n        MINORX = opt.minorx,\n        MINORY = opt.minory,\n        crossX = Math.max(Math.min(0, MAXX), MINX),\n        crossY = Math.max(Math.min(0, MAXY), MINY),\n        ctx,\n        rect;\n\n\n    var drawArrow = function (ctx) {\n        ctx.moveTo(0, 0);\n        ctx.lineTo(3, 1);\n        ctx.lineTo(0, 2);\n        ctx.lineTo(1, 1);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n    };\n\n    var drawEastArrow = function (rect) {\n        rect.rel(1,0)\n        .width(20).height(8).hline()\n        .rel(1,0).width(10).offset(-10,-4)\n        .projectDrawing(drawArrow, 3, 2, 0);\n    };\n    \n    var drawWestArrow = function (rect) {\n        rect.width(20).height(8).offset(-20,0).hline()\n        .width(10).offset(0,-4)\n        .projectDrawing(drawArrow, 3, 2, Math.PI);\n    };\n    \n    var drawNorthArrow = function (rect) {\n        rect.height(20).offset(0,-20).vline()\n        .height(10).width(8).offset(-4,0)\n        .projectDrawing(drawArrow,3,2,Math.PI*1.5);\n    };\n\n    var drawSouthArrow = function (rect) {\n        rect.rel(0,1).height(20).vline()\n        .rel(0,1).height(10).width(8).offset(-4,-10)\n        .projectDrawing(drawArrow, 3, 2, Math.PI*0.5);\n    }\n    \n    var drawXTick = function  (x) {\n        if (x === crossX) return;\n        carta.rect(x, crossY)\n        .rel(0,1).height(5).vline()\n        .offset(0,20).text(''+x, 0, 0);\n    };\n    \n    var drawYTick = function (y) {\n        if (y === crossY) return;\n        carta.rect(crossX, y)\n        .rel(0,1).width(5).offset(-5,0).hline()\n        .offset(-8,3).text(''+y, 0, 0);\n    };\n\n    var rangeTicks = function (min, max, step)  {\n        var incr = function (y) {\n                return Math.floor((y+step)/step)*step;\n            },\n            x = incr(min),\n            t = [];\n        while (x < max) {\n            t.push(x);\n            x = incr(x);\n        }\n        return t;\n    };\n\n    var drawXAxis = function () {\n        var xAxis = carta.rect(MINX, crossY).rel(0,1).hline();\n        if (crossX < MAXX) drawEastArrow(xAxis);\n        if (MINX < crossX) drawWestArrow(xAxis);\n        ctx.textAlign = 'center';\n        rangeTicks(MINX, MAXX, MAJORX).forEach(drawXTick);\n    };\n    \n    var drawYAxis = function () {\n        var yAxis = carta.rect(crossX, MINY).vline();\n        if (crossY < MAXY) drawNorthArrow(yAxis);\n        if (MINY < crossY) drawSouthArrow(yAxis);\n        ctx.textAlign = 'right';    \n        rangeTicks(MINY, MAXY, MAJORY).forEach(drawYTick);\n    };\n\n    var drawMinorGrid = function () {\n        rangeTicks(MINX, MAXX, MINORX).forEach(function (x) { carta.vline(x); });\n        rangeTicks(MINY, MAXY, MINORY).forEach(function (y) { carta.hline(y); });\n    };\n    \n    var drawMajorGrid = function () {\n        rangeTicks(MINX, MAXX, MAJORX).forEach(function (x) { carta.vline(x); });\n        rangeTicks(MINY, MAXY, MAJORY).forEach(function (y) { carta.hline(y); });\n    };\n\n    \n    \n    rect = carta.rect();\n    ctx = rect.ctx;\n    ctx.save();\n    ctx.translate(0.5, 0.5);\n    ctx.lineWidth = 1;\n\n\n    ctx.fillStyle = opt.background;\n    rect.fill();\n    \n\n    ctx.strokeStyle = opt.minor;\n    drawMinorGrid();\n\n    ctx.strokeStyle = opt.major;\n    drawMajorGrid();\n\n    ctx.font = opt.font;\n    ctx.strokeStyle  = opt.color;\n    ctx.fillStyle = opt.color;\n    drawXAxis();\n    drawYAxis();\n\n    ctx.restore();\n};\n\n\n\nvar defaults = {\n    background: '#fff',\n    color: '#000',\n    font: 'bold 12px monospace',\n    minor: '#eee',\n    major: '#ccc',\n    minx: 0,\n    maxx: 1,\n    majorx: 1,\n    minorx: 1,\n    miny: 0,\n    maxy: 1,\n    majory: 1,\n    minory: 1,\n};\n\n\n\nvar Graph = function (opts) {\n    copyProps(this, defaults, opts);\n};\n\nGraph.prototype.set = function (props) {\n    copyProps(this, this, props)\n};\n\nGraph.prototype._carta = function (rect) {\n    return rect.inset(50).cartesian(\n        this.minx,\n        this.maxx,\n        this.miny,\n        this.maxy\n    )\n} \n\nGraph.prototype.draw = function (rect) {\n    drawGraph(this._carta(rect), this);\n};\n\nGraph.prototype.mapDrawing = function (rect, fn) {\n    this._carta(rect).mapDrawing(fn);\n};\n\nreturn Graph;\n\n","Vector":"\nvar Vector = function (x, y) {\n    if (!(this instanceof Vector)) {\n        return new Vector(x, y);\n    }\n    this.x = x;\n    this.y = y;\n};\n\nVector.vectorizeArgs  = (function () {\n    var pairArgs = function () {\n        var i = 0, args = [];\n        if (arguments[0] instanceof Vector){\n            return arguments;\n        }\n        while (i < arguments.length - 1) {\n            args.push(new Vector(arguments[i++], arguments[i++]));\n        }\n        return args;\n    };\n    return function (fn) {\n        return function () {\n            return fn.apply(this, pairArgs.apply(null, arguments));\n        };\n    };\n})();\n\nVector.mapper = Vector.vectorizeArgs(function (fromMin, fromMax, toMin, toMax) {\n    var scale = toMax.sub(toMin).div(fromMax.sub(fromMin)),\n        offset = toMin.sub(fromMin.mul(scale));\n    return Vector.vectorizeArgs(function (p) {\n       return p.mul(scale).add(offset); \n    });\n});\n\n\nVector.prototype = {\n    pairwise: function (fn, v) {\n        return new Vector(fn(this.x, v.x), fn(this.y, v.y));\n    },\n    neg: function () { return Vector.zero.sub(this); },\n    inv: function () { return Vector.unit.div(this); },\n    eq:  Vector.vectorizeArgs(function (v) {\n        return this.x === v.x && this.y === v.y;\n    }),\n    rot: function (a) {\n        return new Vector(\n            this.x * Math.cos(a) - this.y * Math.sin(a),\n            this.x * Math.sin(a) + this.y * Math.cos(a)\n        );\n    },\n};\n(function (ops) {\n    Object.keys(ops).forEach(function (n) {\n        Vector.prototype[n] = Vector.vectorizeArgs(function (v) {\n            return this.pairwise(ops[n], v);\n        });\n    });\n})({\n    add: function (a, b) { return a + b; },\n    sub: function (a, b) { return a - b; },\n    mul: function (a, b) { return a * b; },\n    div: function (a, b) { return a / b; },\n    del: function (a, b) { return Math.abs(a-b); }\n});\n\nVector.unit = new Vector(1, 1);\nVector.zero = new Vector(0, 0);\n\nreturn Vector;","animate":"\n        var animate = (function () {\n          var animation = null;\n          return function (ctx, drawer, error) {\n            animation && window.cancelAnimationFrame(animation);\n            animation = window.requestAnimationFrame(function drawLoop (time) {\n              try {\n                if (!drawer(ctx, time)) return true; //break animation if drawer doesnt return truthy value.\n                animation  = window.requestAnimationFrame(drawLoop);\n              } catch(e) {\n                return error(e);\n              }\n            });\n          };\n        })();\n","burndown":"var copyProps = this.load('copyProps');\nvar rect = this.load('rect');\nvar Graph = this.load('Graph');\n\nvar defaults = {\n    days: 9,\n    points: 200,\n    buffer: 0\n}\n\n\nvar calcSteps = function (points, max) {\n    var alt = [2, 5, 10, 20, 50, 100, 500, 1000, 2000, 5000, 10000];\n    var i = 0;\n    while (alt[i] && points/alt[i] > max) i++;\n    return alt[i];\n};\n\nvar calcGraph = function (burndown) {\n    var p = burndown.points + burndown.buffer;\n    var g = {minx:0, miny:0, majorx: 1};\n    g.minory = calcSteps(p, 40);\n    g.majory = calcSteps(p/g.minory, 10) * g.minory;\n    g.maxy = (Math.floor(p/g.majory) + 1) * g.majory; \n    g.maxx = burndown.days + 0.5;\n    return g;\n};\n\nvar Burndown = function (opts) {\n    copyProps(this, defaults, opts);\n    this._graph = new Graph(calcGraph(this));\n};\n\nBurndown.prototype._drawLine = function (ctx, points, days, color) {\n    ctx.save();\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(0, points);\n    ctx.lineTo(days, 0);\n    ctx.stroke();\n    ctx.restore();\n};\n\n\n\nBurndown.prototype.draw = function (canvas) {\n    var line = this._drawLine,\n        r = rect(canvas),\n        d = this.days,\n        p = this.points,\n        b = this.buffer + p;\n    r.ctx.fillStyle = '#fff';\n    r.fill();\n    this._graph.draw(r);\n    this._graph.mapDrawing(r, function (ctx) {\n        line(ctx, b, d, 'rgba(255,0,0,0.3)');\n        if (b > p) line(ctx, p, d * p / b, 'rgba(0,255,0,0.3)');\n    });\n};\n\nnew Burndown({\n    days: 11,\n    points: 158,\n    buffer: 40\n}).draw(document.querySelector('canvas'));\n\nreturn Burndown;","canvas":"/*\nvar canvas = document.querySelector('#canvas');\nvar canvasPane = document.querySelector('#canvas-pane');\n\nvar canvasSize = (function (canvas, canvasPane) {\n  var autoResize = true;\n  var fix = function (w, h) {\n    autoResize = false;\n    canvas.width = w;\n    canvas.height = h;\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n    canvasPane.style.overflow = 'scroll';\n  };\n  var unfix = function () {\n    autoResize = true;\n    canvas.width = canvasPane.offsetWidth;\n    canvas.height = canvasPane.offsetHeight;\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvasPane.style.overflow = 'hidden';\n  };\n  var onResize = function (ev) {\n    if (!autoResize) return;\n    unfix();\n  };\n  return {\n    fix: fix,\n    unfix: unfix\n  };\n})(canvas, canvasPane);\ncanvasSize.unfix();\n\n\n        var canvasRunner = (function (animate, canvas, canvasSize, Runner) {\n          runner = new Runner({\n            setSize: function (w, h) {\n              if (!w || !h) {\n                canvasSize.unfix()\n              }\n              canvasSize.fix(w, h);\n            },\n            width: function () {\n              return canvas.width;\n            },\n            height: function () {\n              return canvas.height;\n            }\n          });\n          return function (code) {\n            var ctx = canvas.getContext('2d');\n            var error = function (err) {\n              canvasSize.fix(5000,5000);\n              ctx.fillStyle = '#555';\n              ctx.fillRect(0,0, canvas.width, canvas.height);\n              ctx.fillStyle = '#fff';\n              ctx.font = '16px monospace';\n              y = 0;\n              err.stack.split('\\n').forEach(function (line) {\n                y+=20;\n                ctx.fillText(line, 20, y);\n              });\n              console.log(err);\n            }\n            canvasSize.unfix();\n            try {\n              var drawer = runner.run(code);\n            } catch (e) {\n              return error(e);\n            }\n            if (typeof drawer === 'function') {\n              animate(ctx, drawer, error);\n            }\n          }\n        })(animate, canvas, canvasSize, Runner);\n*/\n\n\nvar canvas = document.querySelector('canvas');\nreturn {\n    el: canvas,\n    width: function () { return canvas.width; },\n    height: function () { return canvas.height; },\n    context: function () { return canvas.getContext('2d'); }\n};\n","copyProps":"var copyProps = function (target, source, overrides) {\n    var key, val;\n    overrides = overrides || {};\n    for (key in source) {\n        if (!source.hasOwnProperty(key)) continue;\n        target[key] = (typeof overrides[key] === 'undefined') ? source[key] : overrides[key];\n    }\n};\n\nreturn copyProps;","currentTransform":"/**\n * Polyfill for HTML5 CanvasRenderingContext2D.currentTransform[Inverse].\n * Matt <mabananatt@supermatty.com>, 2012-2013.\n * Please remove the yellow, tasty fruit from my email address in order to contact me.\n *\n * I, the author of this code, grant any entity the right to use this work\n * for any purpose and in any way, without any conditions or restrictions of any kind,\n * unless such conditions or restrictions are required by law.\n *\n * Notwithstanding the above, I would greatly appreciate it if you were to:\n * - Notify me of your use of this code, if any; and/or\n * - Contribute any changes which you may make back to me.\n *\n * There are no warranties as to the operation or failure to operate of this code,\n * nor of its fitness for any particular purpose.\n * \n * Patches, bugfixes, enhancements, use stories etc are welcome - please email me.\n */\n(function() {\n\tvar vendorPrefixes = ['moz', 'webkit', 'khtml', 'o', 'ms'],\n\t\ti,\n\t\tidentityMatrix = [1, 0, 0, 1, 0, 0],\n\t\tcanvas,\n\t\tcontext,\n\t\tcanvasProto,\n\t\tcontextProto,\n\t\toriginalGetContext, originalSave, originalRestore, originalRotate,\n\t\toriginalScale, originalTranslate, originalTransform,\n\t\toriginalSetTransform, originalResetTransform,\n\t\tgetPrototypeOf, defineProperty;\n\t/*\n\tdebug('Object.getPrototypeOf: ', Object.getPrototypeOf);\n\tdebug('Object.defineProperty: ', Object.defineProperty);\n\tdebug('__defineGetter__: ', __defineGetter__);\n\tdebug('__defineSetter__: ', __defineSetter__);\n\t*/\n\tcanvas = document.createElement('canvas');\n\tif (canvas && canvas.getContext) {\n\t\tcontext = canvas.getContext(\"2d\");\n\t} else {\n\t\tcontext = undefined;\n\t}\n\tif (!context) {\n\t\treturn; // Silently do nothing if <canvas> 2D context unavailable\n\t}\n\t// This would be a polyfill for Object.getPrototypeOf,\n\t// except that extending Object.prototype is Evil.\n\tif (Object.getPrototypeOf) {\n\t\tgetPrototypeOf = Object.getPrototypeOf;\n\t} else {\n\t\tgetPrototypeOf = function() {\n\t\t\treturn this.__proto__ || this.constructor.prototype;\n\t\t};\n\t}\n\t// Another would-be polyfill, for Object.defineProperty.\n\t// This only handles the 'accessor descriptor' case, not the 'data descriptor' case.\n\tif (Object.defineProperty) {\n\t\t// NOTE: IE8 has this method, but it only works on DOM objects attached to the DOM tree.\n\t\t// But IE8 doesn't support <canvas>, so we're stuffed anyway and should have bailed earlier.\n\t\tdefineProperty = Object.defineProperty;\n\t} else if (Object.__defineGetter__ && Object.__defineSetter__) {\n\t\t// Old Mozilla property API\n\t\tdefineProperty = function(name, descriptor) {\n\t\t\tif (descriptor.get) {\n\t\t\t\tthis.__defineGetter__(name, descriptor.get);\n\t\t\t}\n\t\t\tif (descriptor.set) {\n\t\t\t\tthis.__defineSetter__(name, descriptor.set);\n\t\t\t}\n\t\t};\n\t} else {\n\t\t// NOTE: IE6-7 have an 'onpropertychange' event, but they also don't support <canvas>,\n\t\t// so it's useless for our purposes, and again we should have bailed earlier.\n\t\tdefineProperty = undefined;\n\t}\n\tcanvasProto = getPrototypeOf(canvas) || HTMLCanvasElement;\n\tcontextProto = getPrototypeOf(context) || CanvasRenderingContext2D;\n\t// Separate polyfills for potentially missing Canvas context methods\n\tif (!('resetTransform' in contextProto)) {\n\t\tcontextProto.resetTransform = function() {\n\t\t\tthis.setTransform.apply(this, identityMatrix.concat());\n\t\t};\n\t}\n\tif ('currentTransform' in contextProto && 'currentTransformInverse' in contextProto) {\n\t\treturn; // Already have the two properties; no polyfill required\n\t}\n\t// If we have defineProperty, and if the browser has prefixed <foo>CurrentTransform[Inverse] properties,\n\t// add renamed non-prefixed properties mirroring them.\n\tfor (i = 0; i < vendorPrefixes.length; i++) {\n\t\tif (defineProperty && !('currentTransform' in contextProto) && ((vendorPrefixes[i] + 'CurrentTransform') in contextProto)) {\n\t\t\tdefineProperty(contextProto, 'currentTransform', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this[vendorPrefixes[i] + 'CurrentTransform'];\n\t\t\t\t},\n\t\t\t\tset: function(newMatrix) {\n\t\t\t\t\tthis.setTransform.apply(this, newMatrix);\n\t\t\t\t},\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t\tdefineProperty(contextProto, 'currentTransformInverse', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this[vendorPrefixes[i] + 'CurrentTransformInverse'];\n\t\t\t\t},\n\t\t\t\t// No setter for inverse matrix\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t\treturn; // We're done at this point.\n\t\t}\n\t}\n\t// If we get here, we still don't have currentTransform[Inverse] properties\n\t// (not even prefixed ones), so we need to track the CTM ourselves.\n\t/*\n\tdebug('currentTransform in contextProto: ', ('currentTransform' in contextProto));\n\tdebug('currentTransformInverse in contextProto: ', ('currentTransformInverse' in contextProto));\n\t*/\n\tif (!('currentTransform' in contextProto) || !('currentTransformInverse' in contextProto)) {\n\t\t// Saved values of over-ridden Canvas methods\n\t\toriginalGetContext = canvasProto.getContext;\n\t\t// Saved values of over-ridden Context methods\n\t\toriginalSave      = contextProto.save;\n\t\toriginalRestore   = contextProto.restore;\n\t\toriginalRotate    = contextProto.rotate;\n\t\toriginalScale     = contextProto.scale;\n\t\toriginalTranslate = contextProto.translate;\n\t\toriginalTransform = contextProto.transform;\n\t\toriginalSetTransform = context.setTransform;\n\t\toriginalResetTransform = contextProto.resetTransform;\n\t\t// Over-ride the Canvas factory method that creates Contexts to create decorated ones\n\t\tcanvasProto.getContext = function() {\n\t\t\t// Workaround: older browsers do not accept 'arguments' as second parameter of Function.apply\n\t\t\tvar context = originalGetContext.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t\tif (Object.defineProperty) {\n\t\t\t\t// Using Object.defineProperty rather than simple assignment in order to hide these 'private' data\n\t\t\t\tObject.defineProperty(context, '_transformMatrix', {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: identityMatrix.concat(),\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t\tObject.defineProperty(context, '_transformStack', {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: [],\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Object.defineProperty unavailable; fall back to simple assignment.\n\t\t\t\t// TODO: Could avoid littering the context by storing these in a private (closed-over)\n\t\t\t\t// hash keyed by context. However JS gives no easy way to associate a unique ID with each context.\n\t\t\t\tcontext._transformMatrix = identityMatrix.concat();\n\t\t\t\tcontext._transformStack = [];\n\t\t\t}\n\t\t\treturn context;\n\t\t};\n\t\t// Over-ride each Context method that modifies the transform matrix\n\t\tcontextProto.save = function() {\n\t\t\tthis._transformStack.push(this._transformMatrix.concat()); // shallow copy\n\t\t\treturn originalSave.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.restore = function() {\n\t\t\tvar mtx = this._transformStack.pop();\n\t\t\tif (mtx) {\n\t\t\t\tthis._transformMatrix = mtx;\n\t\t\t}\n\t\t\treturn originalRestore.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.translate = function(x, y) {\n\t\t\tthis._transformMatrix[4] += this._transformMatrix[0] * x + this._transformMatrix[2] * y;\n\t\t\tthis._transformMatrix[5] += this._transformMatrix[1] * x + this._transformMatrix[3] * y;\n\t\t\treturn originalTranslate.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.scale = function(x, y) {\n\t\t\tthis._transformMatrix[0] *= x;\n\t\t\tthis._transformMatrix[1] *= x;\n\t\t\tthis._transformMatrix[2] *= y;\n\t\t\tthis._transformMatrix[3] *= y;\n\t\t\treturn originalScale.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.rotate = function(angle) {\n\t\t\tvar c = Math.cos(angle), s = Math.sin(angle);\n\t\t\tthis._transformMatrix = [\n\t\t\t\tthis._transformMatrix[0] *  c + this._transformMatrix[2] * s,\n\t\t\t\tthis._transformMatrix[1] *  c + this._transformMatrix[3] * s,\n\t\t\t\tthis._transformMatrix[0] * -s + this._transformMatrix[2] * c,\n\t\t\t\tthis._transformMatrix[1] * -s + this._transformMatrix[3] * c,\n\t\t\t\tthis._transformMatrix[4],\n\t\t\t\tthis._transformMatrix[5]\n\t\t\t];\n\t\t\treturn originalRotate.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.transform = function(a, b, c, d, e, f) {\n\t\t\tthis._transformMatrix = [\n\t\t\t\tthis._transformMatrix[0] * a + this._transformMatrix[2] * b,\n\t\t\t\tthis._transformMatrix[1] * a + this._transformMatrix[3] * b,\n\t\t\t\tthis._transformMatrix[0] * c + this._transformMatrix[2] * d,\n\t\t\t\tthis._transformMatrix[1] * c + this._transformMatrix[3] * d,\n\t\t\t\tthis._transformMatrix[0] * e + this._transformMatrix[2] * f + this._transformMatrix[4],\n\t\t\t\tthis._transformMatrix[1] * e + this._transformMatrix[3] * f + this._transformMatrix[5]\n\t\t\t];\n\t\t\treturn originalTransform.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.setTransform = function(a, b, c, d, e, f) {\n\t\t\tthis._transformMatrix = [ a, b, c, d, e, f];\n\t\t\treturn originalSetTransform.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t\tcontextProto.resetTransform = function() {\n\t\t\tthis._transformMatrix = identityMatrix.concat();\n\t\t\treturn originalResetTransform.apply(this, Array.prototype.slice.call(arguments, 0));\n\t\t};\n\t}\n\tif (defineProperty && !('currentTransform' in contextProto)) {\n\t\tdefineProperty(contextProto, 'currentTransform', {\n\t\t\tget: function() {\n\t\t\t\treturn this._transformMatrix;\n\t\t\t},\n\t\t\tset: function(newMatrix) {\n\t\t\t\tthis.setTransform.apply(this, newMatrix);\n\t\t\t},\n\t\t\tconfigurable: false,\n\t\t\tenumerable: true\n\t\t});\n\t}\n\tif (defineProperty && !('currentTransformInverse' in contextProto)) {\n\t\tdefineProperty(contextProto, 'currentTransformInverse', {\n\t\t\tget: function() {\n\t\t\t\tvar a = this._transformMatrix[0], b = this._transformMatrix[1],\n\t\t\t\t\tc = this._transformMatrix[2], d = this._transformMatrix[3],\n\t\t\t\t\te = this._transformMatrix[4], f = this._transformMatrix[5],\n\t\t\t\t\tad_minus_bc = a * d - b * c,\n\t\t\t\t\tbc_minus_ad = b * c - a * d;\n\t\t\t\treturn [\n\t\t\t\t\td / ad_minus_bc, b / bc_minus_ad,\n\t\t\t\t\tc / bc_minus_ad, a / ad_minus_bc,\n\t\t\t\t\t(d * e - c * f) / bc_minus_ad, (b * e - a * f) / ad_minus_bc\n\t\t\t\t];\n\t\t\t},\n\t\t\tconfigurable: false,\n\t\t\tenumerable: true\n\t\t});\n\t}\n})();","drawGrid":"var rangeTicks = this.load('rangeTicks');\nvar drawGrid = function (ctx, rect, minx, maxx, miny, maxy, stepx, stepy) {\n  \n};\n\nreturn drawGrid;\n","rect":"var unscaleStroke = this.load('unscaleStroke');\nvar Vector = this.load('Vector');\nvar CartesianRect = this.load('CartesianRect');\n\nvar Rect = function (ctx, w, h, x, y) {\n    this.ctx = ctx;\n    this.x = Math.round(x || 0); \n    this.y = Math.round(y || 0);\n    this.w = Math.round(w);\n    this.h = Math.round(h);\n};\n\n//return a new rect of given width and height, \n//with it's top left corner at the given offset.\n//relative to my top left corner.\nRect.prototype.rect = Vector.vectorizeArgs(function (d, o) {\n    o = o || Vector.zero;\n    o = o.add(this.x, this.y);\n    return new Rect(this.ctx, d.x, d.y, o.x, o.y); \n});\n\nRect.prototype.height = function (h) {\n    return this.rect(this.w, h);\n};\n\nRect.prototype.width = function (w) {\n    return this.rect(w, this.h);\n};\n \nRect.prototype.fill = function (color) {\n    if (color) {\n        this.ctx.fillStyle = color;\n    }\n    this.ctx.fillRect(this.x, this.y, this.w, this.h);\n    return this;\n};\n\nRect.prototype.mapDrawing = function (fn) {\n    var ctx = this.ctx;\n    ctx.save();\n    ctx.translate(this.x, this.y);\n    var restoreStroke = unscaleStroke(ctx);\n    fn.call(null, ctx);\n    restoreStroke();\n    ctx.restore();\n}\n\nRect.prototype.projectDrawing = function (fn, w, h, a) {\n\n    w = w || this.w;\n    h = h || this.h;\n    a = a || 0;\n\n    var self = this;\n    var transform = function (ctx) {\n        ctx.translate(self.w/2, self.h/2 );\n        var A = a;\n        while (A < 0) A += 2 * Math.PI;\n        if (A > Math.PI) A = A - Math.PI;\n        if (A > Math.PI / 2) A = Math.PI - A;\n        ctx.scale(\n            self.w / (self.w*Math.cos(A) + self.h * Math.sin(A)),\n            self.h / (self.w*Math.sin(A) + self.h * Math.cos(A))\n        );\n        ctx.rotate(a);\n        ctx.translate(-self.w/2, -self.h/2);\n        ctx.scale(self.w/w, self.h/h);\n    }\n    \n    this.mapDrawing(function (ctx) {\n        ctx.save();\n        transform(ctx);\n        fn.call(null, ctx);\n        ctx.restore();\n    });\n};\n\n\n\nRect.prototype.hline = function (y, color) {\n    if (color) this.ctx.strokeStyle = color;\n    y = Math.round((y || 0) + this.y);\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.x, y);\n    this.ctx.lineTo(this.x + this.w, y);\n    this.ctx.stroke();\n    return this;\n};\n\nRect.prototype.vline = function (x, color) {\n    if (color) this.ctx.strokeStyle = color;\n    x = Math.round((x || 0) + this.x);\n    this.ctx.beginPath();\n    this.ctx.moveTo(x, this.y);\n    this.ctx.lineTo(x, this.y + this.h);\n    this.ctx.stroke();\n    return this;\n};\nRect.prototype.text = function (text) {\n    this.ctx.fillText(text, this.x, this.y);\n    return this;\n}\nRect.prototype.cartesian = function (minx, maxx, miny, maxy) {\n    return new CartesianRect(this, minx, maxx, miny, maxy);\n};\n\nRect.prototype.offset = Vector.vectorizeArgs(function (o) {\n    return this.rect(this.w, this.h, o.x, o.y);\n});\n\nRect.prototype.rel = Vector.vectorizeArgs(function (steps) {\n   return this.offset(steps.mul(this.w, this.h)); \n});\n\n//return a new rect of given delta-width and offset\n//relative current corner\nRect.prototype.delta  = Vector.vectorizeArgs(function (dd, o) {\n    return this.rect(dd.add(this.w, this.h), o);    \n});\n\n\n//return a rect with the edges altered in their \n//respective directions\nRect.prototype.edges = function (l, t, r, b) {\n    return this.delta(l + r, t + b, -l, -t);\n};\n\n//rect that is inset a certain number of pixels\n//from each edge of the original.\nRect.prototype.inset = function (i) {\n    return this.edges(-i, -i, -i, -i);\n};\n//rect that is outset a certain number of pixels\n//from each edge of the original\nRect.prototype.outset = function (o) {\n    return this.edges(o,o,o,o);\n};\n\n\n\n\n\n// return function that gets the rect\n// of a canvas.\nreturn function (canvasElement) {\n    return new Rect(\n        canvasElement.getContext('2d'),\n        canvasElement.width,\n        canvasElement.height\n    );\n};","testDrawGrid":"var MINX = -60, MAXX =210, MAJORX = 20, MINORX = 2;\nvar MINY = -50, MAXY = 220, MAJORY = 50,  MINORY =10;\n\nvar canvas = this.load('canvas');\nvar Rect = this.load('Rect');\n\n\n\n\n\n\n\n\n\n\nvar drawGraph = function (rect, opt) {\n    \n    var ctx, carta;\n    \n    var crossX = Math.max(Math.min(0, MAXX), MINX);\n    var crossY = Math.max(Math.min(0, MAXY), MINY);\n\n    var drawArrow = function (ctx) {\n        ctx.moveTo(0, 0);\n        ctx.lineTo(3, 1);\n        ctx.lineTo(0, 2);\n        ctx.lineTo(1, 1);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n    };\n\n    var drawEastArrow = function (rect) {\n        rect.rel(1,0)\n        .width(20).height(8).hline()\n        .rel(1,0).width(10).offset(-10,-4)\n        .mapDrawing(drawArrow, 3, 2, 0);\n    };\n    \n    var drawWestArrow = function (rect) {\n        rect.width(20).height(8).offset(-20,0).hline()\n        .width(10).offset(0,-4)\n        .mapDrawing(drawArrow, 3, 2, Math.PI);\n    };\n    \n    var drawNorthArrow = function (rect) {\n        rect.height(20).offset(0,-20).vline()\n        .height(10).width(8).offset(-4,0)\n        .mapDrawing(drawArrow,3,2,Math.PI*1.5);\n    };\n\n    var drawSouthArrow = function (rect) {\n        rect.rel(0,1).height(20).vline()\n        .rel(0,1).height(10).width(8).offset(-4,-10)\n        .mapDrawing(drawArrow, 3, 2, Math.PI*0.5);\n    }\n    \n    var drawXTick = function  (x) {\n        if (x === crossX) return;\n        carta.rect(x, crossY)\n        .rel(0,1).height(5).vline()\n        .offset(0,20).text(''+x, 0, 0);\n    };\n    \n    var drawYTick = function (y) {\n        if (y === crossY) return;\n        carta.rect(crossX, y)\n        .rel(0,1).width(5).offset(-5,0).hline()\n        .offset(-8,3).text(''+y, 0, 0);\n    };\n\n    var rangeTicks = function (min, max, step)  {\n        var incr = function (y) {\n                return Math.floor((y+step)/step)*step;\n            },\n            x = incr(min),\n            t = [];\n        while (x < max) {\n            t.push(x);\n            x = incr(x);\n        }\n        return t;\n    };\n\n    var drawXAxis = function () {\n        var xAxis = carta.rect(MINX, crossY).rel(0,1).hline();\n        if (crossX < MAXX) drawEastArrow(xAxis);\n        if (MINX < crossX) drawWestArrow(xAxis);\n        ctx.textAlign = 'center';\n        rangeTicks(MINX, MAXX, MAJORX).forEach(drawXTick);\n    };\n    \n    var drawYAxis = function () {\n        var yAxis = carta.rect(crossX, MINY).vline();\n        if (crossY < MAXY) drawNorthArrow(yAxis);\n        if (MINY < crossY) drawSouthArrow(yAxis);\n        ctx.textAlign = 'right';    \n        rangeTicks(MINY, MAXY, MAJORY).forEach(drawYTick);\n    };\n\n    var drawMinorGrid = function () {\n        rangeTicks(MINX, MAXX, MINORX).forEach(function (x) { carta.vline(x); });\n        rangeTicks(MINY, MAXY, MINORY).forEach(function (y) { carta.hline(y); });\n    };\n    \n    var drawMajorGrid = function () {\n        rangeTicks(MINX, MAXX, MAJORX).forEach(function (x) { carta.vline(x); });\n        rangeTicks(MINY, MAXY, MAJORY).forEach(function (y) { carta.hline(y); });\n    };\n\n    \n    ctx = rect.ctx;\n    ctx.save();\n    ctx.translate(0.5, 0.5);\n    ctx.lineWidth = 1;\n    \n    carta = rect.inset(20).cartesian(MINX, MAXX, MINY, MAXY);\n\n\n    ctx.fillStyle = opt.background;\n    rect.fill();\n    \n\n    ctx.strokeStyle = opt.minor;\n    drawMinorGrid();\n\n    ctx.strokeStyle = opt.major;\n    drawMajorGrid();\n\n    ctx.font = opt.font;\n    ctx.strokeStyle  = opt.color;\n    ctx.fillStyle = opt.color;\n    drawXAxis();\n    drawYAxis();\n\n    ctx.restore();\n};\n\n\nvar fancy = {\n    font: '12px monospace',\n    color: 'hsla(70, 100%, 50%, 1)',\n    minor: 'hsla(70, 100%, 50%, 0.1)',\n    major: 'hsla(70, 100%, 50%, 0.2)' ,\n    background: 'hsla(70, 100%, 3%, 1)'\n};\n\nvar defaults = {\n    background: '#fff',\n    color: '#000',\n    font: 'bold 12px monospace',\n    minor: '#eee',\n    major: '#ccc',\n};\n\nvar setDefaults = function (opts) {\n    \n}\n\ndrawGraph(Rect.fromCanvas(canvas.el), fancy);\n","unscaleStroke":"this.load('currentTransform');\n\nvar getUnscaledStroke = function (ctx, orig) {\n    return function () {\n        var t = ctx.currentTransform;\n        ctx.resetTransform();\n        orig.call(ctx);\n        ctx.setTransform(t.a, t.b, t.c, t.d, t.e, t.f);\n    };\n};\n\nvar unscaleStroke = function (ctx) {\n    var orig = ctx.stroke;\n    ctx.stroke = getUnscaledStroke(ctx, orig);\n    return function () { ctx.stroke = orig; };\n};\n\nreturn unscaleStroke;"}