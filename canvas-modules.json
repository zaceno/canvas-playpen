{"":"\nvar Vector = this.load('Vector');\nreturn Vector.vectorizeArgs(function (fromMin, fromMax, toMin, toMax) {\n    var scale = toMax.sub(toMin).div(fromMax.sub(fromMin)),\n        offset = toMin.sub(fromMin.mul(this.scale));\n    return Vector.vectorizeArgs(function (p) {\n       return p.mul(scale).add(offset); \n    });\n});\n","Rect":"var Vector = this.load('Vector');\n\nvar Rect = function (w, h, x, y) {\n    this.x = x || 0; \n    this.y = y || 0;\n    this.w = w;\n    this.h = h;\n};\n\n\n\n//return a new rect of given width and height, \n//with it's top left corner at the given offset.\n//relative to my top left corner.\nRect.prototype.rect = Vector.vectorizeArgs(function (d, o) {\n    o = o || Vector.zero;\n    o = o.add(this.x, this.y);\n    return new Rect(d.x, d.y, o.x, o.y);\n});\n\nRect.prototype.point = Vector.vectorizeArgs(function (p) {\n    return p.add(this.x, this.y);\n});\n\nRect.prototype.cartesianMap = Vector.vectorizeArgs(function (min, max) {\n    var self = this;\n    var map = Vector.mapper(min.x, min.y, max.x, max.y, 0, this.h, this.w, 0);\n    return Vector.vectorizeArgs(function (p) { return self.point(map(p)); });\n});\n\n//return a new rect of given delta-width and offset\n//relative current corner\nRect.prototype.delta  = Vector.vectorizeArgs(function (dd, o) {\n    return this.rect(dd.add(this.w, this.h), o);    \n});\n\nRect.prototype.offset = Vector.vectorizeArgs(function (o) {\n    return this.rect(this.w, this.h, o.x, o.y);\n});\n\n//return a rect with the edges altered in their \n//respective directions\nRect.prototype.edges = function (l, t, r, b) {\n    return this.delta(l + r, t + b, -l, -t);\n};\n\n//rect that is inset a certain number of pixels\n//from each edge of the original.\nRect.prototype.inset = function (i) {\n    return this.edges(-i, -i, -i, -i);\n};\n//rect that is outset a certain number of pixels\n//from each edge of the original\nRect.prototype.outset = function (o) {\n    return this.edges(o,o,o,o);\n};\n\nRect.prototype._part = Vector.vectorizeArgs(function (part, offset) {\n    var dims = new Vector(this.w, this.h);\n    part = part.pairwise(function (a, b) {\n        if (a < -b) return 0;\n        if (-b <= a && a <= 0) return b + a;\n        if (0 < a && a <= b) return a;\n        if (b < a) return b;\n    }, dims);\n    offset = offset.pairwise(function (a, b) {\n        if (a < -b) return 0;\n        if (-b <= a && a < 0 ) return b + a;\n        if (0 <= a && a <= b) return a;\n        if (b < a ) return b;\n    }, dims);\n    offset = offset.pairwise(function (a, b) {\n        if (b < a ) return b;\n        return a;\n    }, dims.sub(part));\n    return this.rect(part, offset);\n});\nRect.prototype.left    = function (z) { return this._part(z, 0, 0, 0); }; \nRect.prototype.top     = function (z) { return this._part(0, z, 0, 0); }; \nRect.prototype.right   = function (z) { return this._part(z, 0, -z, 0); };\nRect.prototype.bottom  = function (z) { return this._part(0, z, 0, -z); }; \nRect.prototype.rleft   = function (z) { return this.right(-z); }; \nRect.prototype.rtop    = function (z) { return this.bottom(-z); }; \nRect.prototype.rright  = function (z) { return this.left(-z); }; \nRect.prototype.rbottom = function (z) { return this.top(-z); }; \n\n\n\n\nreturn Rect;","Vector":"\nvar Vector = function (x, y) {\n    if (!(this instanceof Vector)) {\n        return new Vector(x, y);\n    }\n    this.x = x;\n    this.y = y;\n};\n\nVector.vectorizeArgs  = (function () {\n    var pairArgs = function () {\n        var i = 0, args = [];\n        if (arguments[0] instanceof Vector){\n            return arguments;\n        }\n        while (i < arguments.length - 1) {\n            args.push(new Vector(arguments[i++], arguments[i++]));\n        }\n        return args;\n    };\n    return function (fn) {\n        return function () {\n            return fn.apply(this, pairArgs.apply(null, arguments));\n        };\n    };\n})();\n\nVector.mapper = Vector.vectorizeArgs(function (fromMin, fromMax, toMin, toMax) {\n    console.log('Vectormapperr', fromMin, fromMax, toMin, toMax);\n    var scale = toMax.sub(toMin).div(fromMax.sub(fromMin)),\n        offset = toMin.sub(fromMin.mul(scale));\n    return Vector.vectorizeArgs(function (p) {\n       return p.mul(scale).add(offset); \n    });\n});\n\n\nVector.prototype = {\n    pairwise: function (fn, v) {\n        return new Vector(fn(this.x, v.x), fn(this.y, v.y));\n    },\n    neg: function () { return Vector.zero.sub(this); },\n    inv: function () { return Vector.unit.div(this); },\n    eq:  Vector.vectorizeArgs(function (v) {\n        return this.x === v.x && this.y === v.y;\n    })\n};\n(function (ops) {\n    Object.keys(ops).forEach(function (n) {\n        Vector.prototype[n] = Vector.vectorizeArgs(function (v) {\n            return this.pairwise(ops[n], v);\n        });\n    });\n})({\n    add: function (a, b) { return a + b; },\n    sub: function (a, b) { return a - b; },\n    mul: function (a, b) { return a * b; },\n    div: function (a, b) { return a / b; },\n});\n\nVector.unit = new Vector(1, 1);\nVector.zero = new Vector(0, 0);\n\nreturn Vector;","animate":"\n        var animate = (function () {\n          var animation = null;\n          return function (ctx, drawer, error) {\n            animation && window.cancelAnimationFrame(animation);\n            animation = window.requestAnimationFrame(function drawLoop (time) {\n              try {\n                if (!drawer(ctx, time)) return true; //break animation if drawer doesnt return truthy value.\n                animation  = window.requestAnimationFrame(drawLoop);\n              } catch(e) {\n                return error(e);\n              }\n            });\n          };\n        })();\n","canvas":"/*\nvar canvas = document.querySelector('#canvas');\nvar canvasPane = document.querySelector('#canvas-pane');\n\nvar canvasSize = (function (canvas, canvasPane) {\n  var autoResize = true;\n  var fix = function (w, h) {\n    autoResize = false;\n    canvas.width = w;\n    canvas.height = h;\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n    canvasPane.style.overflow = 'scroll';\n  };\n  var unfix = function () {\n    autoResize = true;\n    canvas.width = canvasPane.offsetWidth;\n    canvas.height = canvasPane.offsetHeight;\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvasPane.style.overflow = 'hidden';\n  };\n  var onResize = function (ev) {\n    if (!autoResize) return;\n    unfix();\n  };\n  return {\n    fix: fix,\n    unfix: unfix\n  };\n})(canvas, canvasPane);\ncanvasSize.unfix();\n\n\n        var canvasRunner = (function (animate, canvas, canvasSize, Runner) {\n          runner = new Runner({\n            setSize: function (w, h) {\n              if (!w || !h) {\n                canvasSize.unfix()\n              }\n              canvasSize.fix(w, h);\n            },\n            width: function () {\n              return canvas.width;\n            },\n            height: function () {\n              return canvas.height;\n            }\n          });\n          return function (code) {\n            var ctx = canvas.getContext('2d');\n            var error = function (err) {\n              canvasSize.fix(5000,5000);\n              ctx.fillStyle = '#555';\n              ctx.fillRect(0,0, canvas.width, canvas.height);\n              ctx.fillStyle = '#fff';\n              ctx.font = '16px monospace';\n              y = 0;\n              err.stack.split('\\n').forEach(function (line) {\n                y+=20;\n                ctx.fillText(line, 20, y);\n              });\n              console.log(err);\n            }\n            canvasSize.unfix();\n            try {\n              var drawer = runner.run(code);\n            } catch (e) {\n              return error(e);\n            }\n            if (typeof drawer === 'function') {\n              animate(ctx, drawer, error);\n            }\n          }\n        })(animate, canvas, canvasSize, Runner);\n*/\n\n\nvar canvas = document.querySelector('canvas');\nreturn {\n    width: function () { return canvas.width; },\n    height: function () { return canvas.height; },\n    context: function () { return canvas.getContext('2d'); }\n};\n","drawGrid":"var drawGrid = function (ctx, rect, minx, maxx, miny, maxy, stepx, stepy) {\n    ctx.save();\n    ctx.translate(0.5, 0.5);\n\n    var map = rect.cartesianMap(minx, miny, maxx, maxy);\n    ticks = function (min, max, step) {\n        var incr = function (y) {\n            return Math.floor((y+step)/step)*step;\n        },\n        x = incr(min),\n        t = [];\n        while (x < max) {\n            t.push(x);\n            x = incr(x);\n        }\n        return t;\n    };\n    var gridLine = function (x1, y1, x2, y2) {\n        ctx.beginPath();\n        var p1 = map(x1, y1);\n        var p2 = map(x2, y2);\n        console.log(p1);\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(p2.x, p2.y);\n        ctx.stroke();\n    };\n    ctx.restore();\n    ticks(minx, maxx, stepx).forEach(function (x) {\n        gridLine(x, miny, x, maxy);\n    });\n    ticks(miny, maxy, stepy).forEach(function (y) {\n       gridLine(minx, y, maxx, y); \n    });\n};\n\nreturn drawGrid;\n","testDrawGrid":"var canvas = this.load('canvas');\nvar Rect = this.load('Rect');\nvar drawGrid = this.load('drawGrid');\nvar ctx = canvas.context();\nvar r = new Rect(canvas.width(), canvas.height());\nctx.fillStyle = '#222';\nctx.fillRect(r.x, r.y, r.w, r.h);\nr = r.inset(20);\nctx.fillStyle = '#222';\nctx.fillRect(r.x, r.y, r.w, r.h);\nr = r.inset(50).rright(20).rtop(20);\nctx.fillStyle = 'hsla(70, 100%, 50%, 0.1)';\nctx.fillRect(r.x, r.y, r.w, r.h);\nctx.strokeStyle = 'hsla(70, 100%, 50%, 0.2)';\nctx.lineWidth = 1;\ndrawGrid(ctx, r, -15, 70, 25, 90, 10, 20);\nctx.strokeStyle = 'hsla(70, 100%, 50%, 0.1)';\ndrawGrid(ctx, r, -15, 70, 25, 90, 5, 5);\n\nctx.strokeStyle  = 'hsla(70, 100%, 50%, 1)';\nctx.beginPath();\nvar p;\np = r.point(0, r.h);\nctx.moveTo(p.x, p.y);\np = r.point(r.w + 20, r.h);\nctx.lineTo(p.x, p.y);\nctx.stroke();\n\np = r.point(r.w, r.h - 10);\nctx.save();\nctx.fillStyle  = 'hsla(70, 100%, 50%, 1)';\nctx.translate(p.x + 10, p.y)\nctx.beginPath();\nctx.moveTo(0, 0);\nctx.lineTo(20, 10);\nctx.lineTo(0, 20);\nctx.lineTo(7, 10);\nctx.closePath();\nctx.fill();\nctx.restore();\n\n//ticks & labels on x axis\n"}