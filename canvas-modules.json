{"":"var Vector = this.load('Vector');\n\nvar CartesianRect = function (rect, minx, maxx, miny, maxy) {\n    this._min = new Vector(minx, miny);\n    this._map = Vector.mapper(minx, miny, maxx, maxy, 0, rect.h, rect.w, 0);\n    this._rect = rect;\n};\nCartesianRect.prototype.rect = Vector.vectorizeArgs(function (o, d) {\n    o = o || this._min;\n    d = d || Vector.zero;\n    var mo = this._map(o);\n    return this._rect.rect(this._map(o.add(d)).del(mo), mo);\n});\nCartesianRect.prototype.fill = function () {\n    return this._rect.fill();\n};\nCartesianRect.prototype.hline = function (y) {\n    return this._rect.hline(this._map(0,y).y);\n};\nCartesianRect.prototype.vline = function (x) {\n    return this._rect.vline(this._map(x, 0).x);\n};","CartesianRect":"var Vector = this.load('Vector');\n\nvar CartesianRect = function (rect, minx, maxx, miny, maxy) {\n    this._o = new Vector(minx, miny);\n    this._d = this._o.del(maxx, maxy);\n    this._map = Vector.mapper(minx, miny, maxx, maxy, 0, rect.h, rect.w, 0);\n    this._rect = rect;\n};\nCartesianRect.prototype.rect = Vector.vectorizeArgs(function (o, d) {\n    o = o || this._o;\n    d = o.add(d || this._d);\n    var ro = this._map(o.x, d.y);\n    return this._rect.rect(this._map(d.x, o.y).del(ro), ro);\n});\nCartesianRect.prototype.fill = function () {\n    return this._rect.fill();\n};\nCartesianRect.prototype.hline = function (y) {\n    return this._rect.hline(this._map(0,y).y);\n};\nCartesianRect.prototype.vline = function (x) {\n    return this._rect.vline(this._map(x, 0).x);\n};\n\nreturn CartesianRect;","Graph":"var MINX = -30, MAXX = 100, MAJORX = 50, MINORX = 20;\nvar MINY = -20, MAXY = 50, MAJORY = 10, MINORY = 2;\nvar Vector = this.load('Vector');\nvar Rect = this.load('Rect');\nvar canvas = this.load('canvas');\nvar ctx = canvas.context();\nvar fill = function (r, color) {\n    if (color) ctx.fillStyle = color;\n    ctx.fillRect(r.x, r.y, r.w, r.h);\n};\nvar canvasRect = new Rect(canvas.width(), canvas.height());\nfill(canvasRect, '#222');\nvar graphRect = canvasRect.inset(20);\nfill(graphRect, '#333')\n\n//grid\nvar gridRect = graphRect.inset(50);\nfill(gridRect, 'hsla(60, 100%, 50%, 0.1)');\n\nScalarMap = function (fromMin, fromMax, toMin, toMax) {\n    this.scale = (toMax - toMin) / (fromMax - fromMin);\n    this.offset = toMin - fromMin * this.scale;\n};\nScalarMap.prototype.map = function (x) { return this.scale * x + this.offset; };\nScalarMap.prototype.delta = function (d) { return Math.abs(this.scale * d); };\n\n\nvar CartesianRect = function (rect, minx, maxx, miny, maxy) {\n    this._rect = rect;\n    this._mx = new ScalarMap(minx, maxx, 0, rect.w);\n    this._my =  new ScalarMap(miny, maxy, rect.h, 0)\n}\nCartesianRect.prototype.point = Vector.vectorizeArgs(function (p) {\n    return new Vector(this._mx.map(p.x), this._my.map(p.y));\n});\nCartesianRect.prototype.rect = Vector.vectorizeArgs(function (d, o) {\n    var w = this._mx.delta(d.x);\n    var h = this._my.delta(d.y);\n    var x = this._mx.map(o.x);\n    var y = this._my.map(o.y);\n    y = y - h;\n    return this._rect.rect(w, h, x, y);\n});\n\n\n/*\nTODO: \n    \n    Split grid on minor steps, and draw lines for each step.\n    function for splitting a range into steps of certain size around zero\n    possibly as part of a range object that can be mapped to some other \n    range, and use that to make the scalar maps. Might allow removing the\n    \"slices thing\" if you just return an array of points in a range.\n    then for each slice map that point to a rect, and make a line on the\n    left side of the rect.\n    \n    do that for minor as well as major steps, both axes. That completes the grid part\n    Then do the axes lines, by defining rects from the base.\n    draw lines. draw ticks using same rect division according to range\n    draw labels, based on the rangeparts dweveloped\n    draw arrows into rects defined for them. \n    Need rect-drawer functions that draw on rects, and can map a path\n    to a rect using context scaling (and the unmap for stroking)\n\n    combine it all to a graph paper.\n    \n    draw a reference line\n    \n    export code to standalone module from playpen\n    \n    add input fields that dynamically update graph in final app.\n\n    make playpen not just about canvas. canvas is an element we\n    add to and use in the container. Allow us to add other html\n    elements via templates, inject stylesheets for them, and\n    export the total of code that is in the container to stnadalone app.\n    try plotting scatterplot data.\n    try plotting cumulative time series.\n    \n    make the graph scrollable, and interactive\n    \n    \n    \n    \n    \n\n*/\n\n\n\n\nreturn CartesianRect;\n\n\n\n","Rect":"var Vector = this.load('Vector');\nvar CartesianRect = this.load('CartesianRect');\n\nvar Rect = function (ctx, w, h, x, y) {\n    this.ctx = ctx;\n    this.x = Math.round(x || 0); \n    this.y = Math.round(y || 0);\n    this.w = Math.round(w);\n    this.h = Math.round(h);\n};\n\nRect.fromCanvas = function (canvasElement) {\n    return new Rect(\n        canvasElement.getContext('2d'),\n        canvasElement.width,\n        canvasElement.height\n    );\n};\n\n//return a new rect of given width and height, \n//with it's top left corner at the given offset.\n//relative to my top left corner.\nRect.prototype.rect = Vector.vectorizeArgs(function (d, o) {\n    o = o || Vector.zero;\n    o = o.add(this.x, this.y);\n    return new Rect(this.ctx, d.x, d.y, o.x, o.y); \n});\n\nRect.prototype.height = function (h) {\n    return this.rect(this.w, h);\n};\n\nRect.prototype.width = function (w) {\n    return this.rect(w, this.h);\n};\n \nRect.prototype.fill = function (path) {\n    this.ctx.fillRect(this.x, this.y, this.w, this.h);\n    return this;\n};\n\nRect.prototype.mapDrawing = function (fn, w, h, a) {\n    this.ctx.save();\n    this.ctx.translate(this.x, this.y);\n\n    a  = a || 0;\n    if (a) {\n        this.ctx.translate(w/2, h/2);\n        this.ctx.rotate(-a * Math.PI);\n        this.ctx.translate(-w/2, -h/2);\n    }\n\n    var sx = 1, sy = 1;\n    sx = w ? this.w/w : 1;\n    sy = h ? this.h/h : 1;\n    this.ctx.scale(sx, sy);\n\n    this.ctx.beginPath();\n    fn.call(null, this.ctx);\n    this.ctx.restore();\n};\n\n\n\nRect.prototype.line = Vector.vectorizeArgs(function (p1, p2) {\n    p1 = p1.add(this.x, this.y);\n    p2 = p2.add(this.x, this.y);\n    this.ctx.beginPath();\n    this.ctx.moveTo(p1.x, p1.y);\n    this.ctx.lineTo(p2.x, p2.y);\n    this.ctx.stroke();\n    return this;\n});\n\nRect.prototype.hline = function (y) {\n    y = Math.round((y || 0) + this.y);\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.x, y);\n    this.ctx.lineTo(this.x + this.w, y);\n    this.ctx.stroke();\n    return this;\n};\n\nRect.prototype.vline = function (x) {\n    x = Math.round((x || 0) + this.x);\n    this.ctx.beginPath();\n    this.ctx.moveTo(x, this.y);\n    this.ctx.lineTo(x, this.y + this.h);\n    this.ctx.stroke();\n    return this;\n};\nRect.prototype.cartesian = function (minx, maxx, miny, maxy) {\n    return new CartesianRect(this, minx, maxx, miny, maxy);\n};\n\nRect.prototype.offset = Vector.vectorizeArgs(function (o) {\n    return this.rect(this.w, this.h, o.x, o.y);\n});\n\nRect.prototype.rel = Vector.vectorizeArgs(function (steps) {\n   return this.offset(steps.mul(this.w, this.h)); \n});\n\n//return a new rect of given delta-width and offset\n//relative current corner\nRect.prototype.delta  = Vector.vectorizeArgs(function (dd, o) {\n    return this.rect(dd.add(this.w, this.h), o);    \n});\n\n\n//return a rect with the edges altered in their \n//respective directions\nRect.prototype.edges = function (l, t, r, b) {\n    return this.delta(l + r, t + b, -l, -t);\n};\n\n//rect that is inset a certain number of pixels\n//from each edge of the original.\nRect.prototype.inset = function (i) {\n    return this.edges(-i, -i, -i, -i);\n};\n//rect that is outset a certain number of pixels\n//from each edge of the original\nRect.prototype.outset = function (o) {\n    return this.edges(o,o,o,o);\n};\n\n\n\n\n\n\nreturn Rect;","Vector":"\nvar Vector = function (x, y) {\n    if (!(this instanceof Vector)) {\n        return new Vector(x, y);\n    }\n    this.x = x;\n    this.y = y;\n};\n\nVector.vectorizeArgs  = (function () {\n    var pairArgs = function () {\n        var i = 0, args = [];\n        if (arguments[0] instanceof Vector){\n            return arguments;\n        }\n        while (i < arguments.length - 1) {\n            args.push(new Vector(arguments[i++], arguments[i++]));\n        }\n        return args;\n    };\n    return function (fn) {\n        return function () {\n            return fn.apply(this, pairArgs.apply(null, arguments));\n        };\n    };\n})();\n\nVector.mapper = Vector.vectorizeArgs(function (fromMin, fromMax, toMin, toMax) {\n    var scale = toMax.sub(toMin).div(fromMax.sub(fromMin)),\n        offset = toMin.sub(fromMin.mul(scale));\n    return Vector.vectorizeArgs(function (p) {\n       return p.mul(scale).add(offset); \n    });\n});\n\n\nVector.prototype = {\n    pairwise: function (fn, v) {\n        return new Vector(fn(this.x, v.x), fn(this.y, v.y));\n    },\n    neg: function () { return Vector.zero.sub(this); },\n    inv: function () { return Vector.unit.div(this); },\n    eq:  Vector.vectorizeArgs(function (v) {\n        return this.x === v.x && this.y === v.y;\n    })\n};\n(function (ops) {\n    Object.keys(ops).forEach(function (n) {\n        Vector.prototype[n] = Vector.vectorizeArgs(function (v) {\n            return this.pairwise(ops[n], v);\n        });\n    });\n})({\n    add: function (a, b) { return a + b; },\n    sub: function (a, b) { return a - b; },\n    mul: function (a, b) { return a * b; },\n    div: function (a, b) { return a / b; },\n    del: function (a, b) { return Math.abs(a-b); }\n});\n\nVector.unit = new Vector(1, 1);\nVector.zero = new Vector(0, 0);\n\nreturn Vector;","animate":"\n        var animate = (function () {\n          var animation = null;\n          return function (ctx, drawer, error) {\n            animation && window.cancelAnimationFrame(animation);\n            animation = window.requestAnimationFrame(function drawLoop (time) {\n              try {\n                if (!drawer(ctx, time)) return true; //break animation if drawer doesnt return truthy value.\n                animation  = window.requestAnimationFrame(drawLoop);\n              } catch(e) {\n                return error(e);\n              }\n            });\n          };\n        })();\n","canvas":"/*\nvar canvas = document.querySelector('#canvas');\nvar canvasPane = document.querySelector('#canvas-pane');\n\nvar canvasSize = (function (canvas, canvasPane) {\n  var autoResize = true;\n  var fix = function (w, h) {\n    autoResize = false;\n    canvas.width = w;\n    canvas.height = h;\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n    canvasPane.style.overflow = 'scroll';\n  };\n  var unfix = function () {\n    autoResize = true;\n    canvas.width = canvasPane.offsetWidth;\n    canvas.height = canvasPane.offsetHeight;\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvasPane.style.overflow = 'hidden';\n  };\n  var onResize = function (ev) {\n    if (!autoResize) return;\n    unfix();\n  };\n  return {\n    fix: fix,\n    unfix: unfix\n  };\n})(canvas, canvasPane);\ncanvasSize.unfix();\n\n\n        var canvasRunner = (function (animate, canvas, canvasSize, Runner) {\n          runner = new Runner({\n            setSize: function (w, h) {\n              if (!w || !h) {\n                canvasSize.unfix()\n              }\n              canvasSize.fix(w, h);\n            },\n            width: function () {\n              return canvas.width;\n            },\n            height: function () {\n              return canvas.height;\n            }\n          });\n          return function (code) {\n            var ctx = canvas.getContext('2d');\n            var error = function (err) {\n              canvasSize.fix(5000,5000);\n              ctx.fillStyle = '#555';\n              ctx.fillRect(0,0, canvas.width, canvas.height);\n              ctx.fillStyle = '#fff';\n              ctx.font = '16px monospace';\n              y = 0;\n              err.stack.split('\\n').forEach(function (line) {\n                y+=20;\n                ctx.fillText(line, 20, y);\n              });\n              console.log(err);\n            }\n            canvasSize.unfix();\n            try {\n              var drawer = runner.run(code);\n            } catch (e) {\n              return error(e);\n            }\n            if (typeof drawer === 'function') {\n              animate(ctx, drawer, error);\n            }\n          }\n        })(animate, canvas, canvasSize, Runner);\n*/\n\n\nvar canvas = document.querySelector('canvas');\nreturn {\n    el: canvas,\n    width: function () { return canvas.width; },\n    height: function () { return canvas.height; },\n    context: function () { return canvas.getContext('2d'); }\n};\n","drawGrid":"var rangeTicks = this.load('rangeTicks');\nvar drawGrid = function (ctx, rect, minx, maxx, miny, maxy, stepx, stepy) {\n  \n};\n\nreturn drawGrid;\n","rangeTicks":"var rangeTicks = function (min, max, step)  {\n    var incr = function (y) {\n        return Math.floor((y+step)/step)*step;\n    },\n    x = incr(min),\n    t = [];\n    while (x < max) {\n        t.push(x);\n        x = incr(x);\n    }\n    return t;\n}\nreturn rangeTicks","testDrawGrid":"var MINX = -15, MAXX = 70, MAJORX = 10, MINORX = 5;\nvar MINY = -25, MAXY = 90, MAJORY = 20,  MINORY =5;\nvar rangeTicks = this.load('rangeTicks');\n\nvar canvas = this.load('canvas');\nvar Rect = this.load('Rect');\nvar r = Rect.fromCanvas(canvas.el);\nvar ctx = r.ctx;\nctx.save();\nctx.fillStyle = '#333';\nr.fill();\n\nvar graphRect = r.inset(10);\nctx.fillStyle = '#222';\ngraphRect.fill();\n\nvar gridCart = graphRect.inset(40).cartesian(MINX, MAXX, MINY, MAXY);\nctx.fillStyle = 'hsla(70, 100%, 50%, 0.1)';\ngridCart.fill();\n\n//axis Line\nctx.translate(0.5, 0.5);\nctx.lineWidth = 1;\nctx.strokeStyle  = 'hsla(70, 100%, 50%, 1)';\n\nvar xAxisRect = gridCart.rect(MINX, 0).rel(0,1).height(40).edges(40,0,40,0).fill().hline(0);\nvar yAxisRect = gridCart.rect(0, MINY).width(40).rel(-1,0).edges(0,40,0,40).fill().vline(40);\n\nctx.strokeStyle = 'hsla(70, 100%, 50%, 0.2)';\nrangeTicks(MINX, MAXX, MAJORX).forEach(function (x) { gridCart.vline(x); });\nrangeTicks(MINY, MAXY, MAJORY).forEach(function (y) { gridCart.hline(y); });\n\n\nctx.strokeStyle = 'hsla(70, 100%, 50%, 0.1)';\nrangeTicks(MINX, MAXX, MINORX).forEach(function (x) { gridCart.vline(x); });\nrangeTicks(MINY, MAXY, MINORY).forEach(function (y) { gridCart.hline(y); });\n\n\n\nRect.prototype.mapDrawing = function (fn, w, h, a) {\n    this.ctx.save();\n    this.ctx.translate(this.x, this.y);\n    \n\n    var sx = 1, sy = 1;\n    sx = w ? this.w/w : 1;\n    sy = h ? this.h/h : 1;\n\n\n    if (a) {\n        \n        a = -a*Math.PI\n        a = 0.2\n        \n        ssx = sx * Math.cos(a) - sy * Math.sin(a);\n        ssy = sx * Math.sin(a) + sy * Math.cos(a);\n        sx = ssx;\n        sy = ssy;\n    }\n    this.ctx.scale(sx, sy);\n\n\n    if (a) {\n        this.ctx.translate(w/2, h/2);\n        this.ctx.rotate(a);\n        this.ctx.translate(-w/2, -h/2);\n    }\n\n\n\n\n\n\n    this.ctx.beginPath();\n    fn.call(null, this.ctx);\n    this.ctx.restore();\n};\n\n\n\nvar drawArrow = function (rect, ort) {\n    ctx.save();\n    ctx.fillStyle  = 'hsla(70, 100%, 50%, 1)';\n    rect.mapDrawing(function (ctx) {\n        ctx.moveTo(0, 0);\n        ctx.lineTo(3, 1);\n        ctx.lineTo(0, 2);\n        ctx.lineTo(1, 1);\n        ctx.closePath()\n    }, 3, 2, ort*0.5);\n    ctx.fill();\n    ctx.restore();\n}\n\n\n//axis arrow\nvar xArrowRect = xAxisRect.rel(1,0).offset(-200,-5).width(70).height(150).fill();\ndrawArrow(xArrowRect, 0);\nvar yArrowRect = yAxisRect.rel(1, 0).offset(-5,200).width(150).height(70).fill();\ndrawArrow(yArrowRect, 1);\n\n/*\np = r.point(r.w, r.h - 10);\nctx.save();\nctx.translate(p.x + 10, p.y)\nctx.beginPath();\nctx.moveTo(0, 0);\nctx.lineTo(20, 10);\nctx.lineTo(0, 20);\nctx.lineTo(7, 10);\nctx.closePath();\nctx.fill();\nctx.restore();\n*/\n/*\n\n//ticks & labels on x axis\nctx.textAlign = 'center';\nctx.font = '14px monospace';\nrangeTicks(MINX, MAXX, MAJORX).forEach(function (x) {\n    gridRect.offset(x, MINY).pixels().line(0,0,0,5).text('' + x, 0, 10);\n});*/\nctx.restore();"}